.data
	# criaï¿½ï¿½o de uma matriz 22x22
	mdArray:	.word 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
			.word 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
			.word 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
			.word 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
			.word 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
			.word 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
			.word 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
			.word 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
			.word 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
			.word 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
			.word 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
			.word 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
			.word 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
			.word 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
			.word 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
			.word 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
			.word 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
			.word 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
			.word 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
			.word 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
			.word 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
			.word 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
			
	print:		.byte '*','*','*','*','*','*','*','*','*','*','*','*','*','*','*','*','*','*','*','*','*','*'
			.byte '*','*','*','*','*','*','*','*','*','*','*','*','*','*','*','*','*','*','*','*','*','*'
			.byte '*','*','*','*','*','*','*','*','*','*','*','*','*','*','*','*','*','*','*','*','*','*'
			.byte '*','*','*','*','*','*','*','*','*','*','*','*','*','*','*','*','*','*','*','*','*','*'
			.byte '*','*','*','*','*','*','*','*','*','*','*','*','*','*','*','*','*','*','*','*','*','*'
			.byte '*','*','*','*','*','*','*','*','*','*','*','*','*','*','*','*','*','*','*','*','*','*'
			.byte '*','*','*','*','*','*','*','*','*','*','*','*','*','*','*','*','*','*','*','*','*','*'
			.byte '*','*','*','*','*','*','*','*','*','*','*','*','*','*','*','*','*','*','*','*','*','*'
			.byte '*','*','*','*','*','*','*','*','*','*','*','*','*','*','*','*','*','*','*','*','*','*'
			.byte '*','*','*','*','*','*','*','*','*','*','*','*','*','*','*','*','*','*','*','*','*','*'
			.byte '*','*','*','*','*','*','*','*','*','*','*','*','*','*','*','*','*','*','*','*','*','*'
			.byte '*','*','*','*','*','*','*','*','*','*','*','*','*','*','*','*','*','*','*','*','*','*'
			.byte '*','*','*','*','*','*','*','*','*','*','*','*','*','*','*','*','*','*','*','*','*','*'
			.byte '*','*','*','*','*','*','*','*','*','*','*','*','*','*','*','*','*','*','*','*','*','*'
			.byte '*','*','*','*','*','*','*','*','*','*','*','*','*','*','*','*','*','*','*','*','*','*'
			.byte '*','*','*','*','*','*','*','*','*','*','*','*','*','*','*','*','*','*','*','*','*','*'
			.byte '*','*','*','*','*','*','*','*','*','*','*','*','*','*','*','*','*','*','*','*','*','*'
			.byte '*','*','*','*','*','*','*','*','*','*','*','*','*','*','*','*','*','*','*','*','*','*'
			.byte '*','*','*','*','*','*','*','*','*','*','*','*','*','*','*','*','*','*','*','*','*','*'
			.byte '*','*','*','*','*','*','*','*','*','*','*','*','*','*','*','*','*','*','*','*','*','*'
			.byte '*','*','*','*','*','*','*','*','*','*','*','*','*','*','*','*','*','*','*','*','*','*'
			.byte '*','*','*','*','*','*','*','*','*','*','*','*','*','*','*','*','*','*','*','*','*','*'
			
	# por ser uma matriz quadrada 22x22
	size: 		.word 22
	# constante que representa o tamanho do tipo do dado
	.eqv DATA_SIZE 4
	.eqv CHAR_SIZE 1
	# variavel que representa numero de bombas
	nBombas: .word 0
	# pular linha
	nline:		.asciiz "\n"
	
	#GAME STATE
	state: .word 0 # 0 = inicio do jogo, 1 = loop do jogo, 2 = jogador perdeu, 3 = jogador ganhou
	
	# strings
	pedirLinha: .asciiz "Digite a linha: "
	pedirCol: .asciiz "Digite a coluna: "
	bombaChar: .byte '@'
	perdeu: .asciiz "Voce perdeu!"
	ganhou: .asciiz "Voce ganhou!"
	
	zer: .byte '0'
	one: .byte '1'
	two: .byte '2'
	thr: .byte '3'
	fou: .byte '4'
	fiv: .byte '5'
	six: .byte '6'
	sev: .byte '7'
	eig: .byte '8'
	
	
	aster: .byte '*'
	nAsters: .word 0
	nToWin: .word 0
	
.text
	.globl main
	main:
		#passo 1 colocar bombas na matriz total de 40 bombas
		# contador para 50 bombas
		li $k0, 0
		#limite de bombas
		li $k1, 200
		
		colocarBombas:
		# se contador == 50, terminar loop
		beq $k0, $k1, fimColocarBombas
		
		# Contador de rand
		move $t1, $zero
		
		
		randomNumber:
		li $v0, 30        # Syscall 30: System Time syscall
		syscall           # $a0 will contain the 32 LS bits of the system time
		move $t0, $a0     # Save $a0 value in $t0 

		li $v0, 40        # Syscall 40: Random seed
		add $a0, $zero, $zero   # Set RNG ID to 0
		add $a1, $zero, $t0     # Set Random seed to
		syscall

		li $v0, 42        # Syscall 42: Random int range
		add $a0, $zero, $zero   # Set RNG ID to 0
		li $a1, 21     # Set upper bound to 21 (exclusive)
		syscall                  # Generate a random number and put it in $a0
		add $s1, $zero, $a0     # Copy the random number to $s1
		
		# se contador = 0 ou = 1
		beq $t1, $zero, linhaB
		bne $t1, $zero, colunaB
		
		continueR:
		
		# print random number
		li $v0, 1   # 1 is the system call code to show an int number
		#syscall     # as I said your generated number is at $a0, so it will be printed
		
		# Conferir contador
		bne $t1,$zero,endSwitchCaseR
		# Incrementa contador
		addi $t1,$t1,1
		
		j randomNumber
		
			
		# salvar linha e coluna	
		linhaB:
			move $t8, $s1
			j continueR
		colunaB:
			move $t9, $s1
			j continueR
		
		endSwitchCaseR:
		
		#incrementar contador
		addi $k0, $k0, 1
		#acessar posicao [$t8][$t9]
		#Row major (aqui é colocado a bomba)
		j rowMajorMatrizInteiros
		
		
		fimColocarBombas:
		
		# imprimir matriz de bombas
		#j printMatriz
		
		contarBombas:
			#passo 1.2 verificar quantidade total de bombas
		#contador linha
		li $s1, 0
		#contar col
		li $s2, 1
		#size
		li $s3, 21
		# n bombas
		li $s5, 0 
		# char da bomba
		li $s6, 9
		loopContarBLinha:
			
			#incrementar linha
			addi $s1, $s1, 1
			# se linha == 21, terminar loop
			beq $s1, $s3, fimContarBombas
			
			li $s2, 1
			
			loopContarBCol:
				
				#encontrar posição e analisar se valor é igual a 9
				la $t1, mdArray
				lw $t2, size
				li $t3, 4 # data_size
			
				li $t4, 0
				mul $t4, $s1, $t2 # t4 = rowIndex * size
				add $t4, $t4, $s2 # t4 = t4 + colIndex
				mul $t4, $t4, $t3 # t4 = t4 * dataSize
				add $t1, $t1, $t4 # addr = t1 = t1 + t4
				
				#carregar valor da posicao
				lw $s4, ($t1)
				
				# se *pos == 9
				bne $s4, $s6, continueContarBombas
				addi $s5, $s5, 1 # nBombas++
				
				continueContarBombas:
				#incrementar e verificar
				addi $s2, $s2, 1 # col++
				beq $s2, $s3, loopContarBLinha # if col == 21, terminar
				j loopContarBCol
				
		fimContarBombas:
		
		#armazenar numero de bombas
		sw $s5, nBombas
		# armazenar numero de astericos que deve ter para ganhar
		li $t1, 400
		sub $s5, $t1, $s5
		sw $s5, nToWin
			
		
		rodarJogo:
		
		# contar astericos pare ver se o jogador ganhou
		j contarAst
		
		terminouAst:
		
		#passo 2 imprimir matriz de caracteres
		#j printMatrizChars
		j printChars2
		
		
		
		#passo 3 solicitar linha e coluna do usuario
		# é necessario somar + 1 para os inteiros solicitados
		solicitarLinCol:
		
		# verificar se o jogador perdeu
		lw $a0, state
		li $v0, 2
		beq $a0, $v0, gameover
		
		# verificar se o jogador ganhou
		lw $a0, nToWin
		lw $v0, nAsters
		beq $a0, $v0, gamewin
		
		# armazena linha em t8 e coluna em t9
		la $a0, pedirLinha
		li $v0, 4
		syscall # imprimir 
		
		li $v0, 5
		syscall
		addi $v0, $v0, 1
		move $t8, $v0 # ler
		
		la $a0, pedirCol
		li $v0, 4
		syscall # imprimir 
		
		li $v0, 5
		syscall
		#addi $v0, $v0, 1
		move $t9, $v0 # ler
			
	
		#passo 4 verificar se tem bomba na posiÃ§Ã£o e verificar os vizinhos
		j verificarPos
		
		fimVerificacao:
		
		
		
		
		
		# Mudar os registradores para os de linha e coluna que o usuario quer 
		# Acessando o indici que o usuario escolheu
		
		#mult linha,coluna
		#mtlo $t2
		
		
		
		#passo 5 colocar as dicas
		
		#passo 6 verifica se o usuario ganhou
		
		
		#passo 7 caso o usuario nao ganhou voltar ao passo 2
		
		
		
		j rodarJogo
		
		
		
		# addr = baseAddr + (rowIndex * size + colIndex) * dataSize
		rowMajorMatrizInteiros:
			# row index e col index deve estar sempre armazenados em t8 e t9 respectivamente
			la $t1, mdArray
			lw $t2, size
			li $t3, 4 # data_size
			
			li $t4, 0
			mul $t4, $t8, $t2 # t4 = rowIndex * size
			add $t4, $t4, $t9 # t4 = t4 + colIndex
			mul $t4, $t4, $t3 # t4 = t4 * dataSize
			add $t1, $t1, $t4 # addr = t1 = t1 + t4
			#bomba
			li $t5, 9
			sw $t5, ($t1)
			
			j colocarBombas
			
		
		verificarPos:
			
			# row index e col index deve estar sempre armazenados em t8 e t9 respectivamente
			la $t1, mdArray
			lw $t2, size
			li $t3, 4 # data_size
			li $t5, 9 # bomba
			
			li $t4, 0
			mul $t4, $t8, $t2 # t4 = rowIndex * size
			add $t4, $t4, $t9 # t4 = t4 + colIndex
			mul $t4, $t4, $t3 # t4 = t4 * dataSize
			add $t1, $t1, $t4 # addr = t1 = t1 + t4
			
			lw $t6, ($t1) # carregar valor
			# se valor == 9, mudar caractere
			beq $t6, $t5, colocarCharBomba
			
			# novos registradores para lin e col
			li $s6, 0 # linha
			li $s7, 0 # col
			 contarBombasVizinhas:
			 	#l-1, c-1
			 	subi $s6, $t8, 1
			 	subi $s7, $t9, 1
			 	li $s5, 0 # nbombas vizinhas
			 	
			 	la $t1, mdArray
				lw $t2, size
				li $t3, 4 # data_size
				li $t5, 9 # bomba
			
				li $t4, 0
				mul $t4, $s6, $t2 # t4 = rowIndex * size
				add $t4, $t4, $s7 # t4 = t4 + colIndex
				mul $t4, $t4, $t3 # t4 = t4 * dataSize
				add $t1, $t1, $t4 # addr = t1 = t1 + t4
			
				lw $t6, ($t1) # carregar valor
				
				# se valor == 9, incrementar
				bne $t6, $t5, c2
				addi $s5, $s5, 1
				
				c2:
			 	#l-1, c
			 	subi $s6, $t8, 1
			 	move $s7, $t9
			 	
			 	
			 	la $t1, mdArray
				lw $t2, size
				li $t3, 4 # data_size
				li $t5, 9 # bomba
			
				li $t4, 0
				mul $t4, $s6, $t2 # t4 = rowIndex * size
				add $t4, $t4, $s7 # t4 = t4 + colIndex
				mul $t4, $t4, $t3 # t4 = t4 * dataSize
				add $t1, $t1, $t4 # addr = t1 = t1 + t4
			
				lw $t6, ($t1) # carregar valor
				# se valor == 9, incrementar
				bne $t6, $t5, c3
				addi $s5, $s5, 1
			 	
			 	c3:
			 	#l-1, c+1
			 	subi $s6, $t8, 1
			 	addi $s7, $t9, 1
			 	
			 	
			 	la $t1, mdArray
				lw $t2, size
				li $t3, 4 # data_size
				li $t5, 9 # bomba
			
				li $t4, 0
				mul $t4, $s6, $t2 # t4 = rowIndex * size
				add $t4, $t4, $s7 # t4 = t4 + colIndex
				mul $t4, $t4, $t3 # t4 = t4 * dataSize
				add $t1, $t1, $t4 # addr = t1 = t1 + t4
			
				lw $t6, ($t1) # carregar valor
				# se valor == 9, incrementar
				bne $t6, $t5, c4
				addi $s5, $s5, 1
			 	
			 	c4:
			 	#l, c-1
			 	move $s6, $t8
			 	subi $s7, $t9, 1
			 	
			 	
			 	la $t1, mdArray
				lw $t2, size
				li $t3, 4 # data_size
				li $t5, 9 # bomba
			
				li $t4, 0
				mul $t4, $s6, $t2 # t4 = rowIndex * size
				add $t4, $t4, $s7 # t4 = t4 + colIndex
				mul $t4, $t4, $t3 # t4 = t4 * dataSize
				add $t1, $t1, $t4 # addr = t1 = t1 + t4
			
				lw $t6, ($t1) # carregar valor
				# se valor == 9, incrementar
				bne $t6, $t5, c5
				addi $s5, $s5, 1
			 	
			 	c5:
			 	#l, c+1
			 	move $s6, $t8
			 	addi $s7, $t9, 1
			 	
			 	
			 	la $t1, mdArray
				lw $t2, size
				li $t3, 4 # data_size
				li $t5, 9 # bomba
			
				li $t4, 0
				mul $t4, $s6, $t2 # t4 = rowIndex * size
				add $t4, $t4, $s7 # t4 = t4 + colIndex
				mul $t4, $t4, $t3 # t4 = t4 * dataSize
				add $t1, $t1, $t4 # addr = t1 = t1 + t4
			
				lw $t6, ($t1) # carregar valor
				# se valor == 9, incrementar
				bne $t6, $t5, c6
				addi $s5, $s5, 1
				
			 	c6:
			 	#l+1, c-1
			 	addi $s6, $t8, 1
			 	subi $s7, $t9, 1
			 	
			 	
			 	la $t1, mdArray
				lw $t2, size
				li $t3, 4 # data_size
				li $t5, 9 # bomba
			
				li $t4, 0
				mul $t4, $s6, $t2 # t4 = rowIndex * size
				add $t4, $t4, $s7 # t4 = t4 + colIndex
				mul $t4, $t4, $t3 # t4 = t4 * dataSize
				add $t1, $t1, $t4 # addr = t1 = t1 + t4
			
				lw $t6, ($t1) # carregar valor
				# se valor == 9, incrementar
				bne $t6, $t5, c7
				addi $s5, $s5, 1
			 	
			 	c7:
			 	#l+1, c
			 	addi $s6, $t8, 1
			 	move $s7, $t9
			 	
			 	
			 	la $t1, mdArray
				lw $t2, size
				li $t3, 4 # data_size
				li $t5, 9 # bomba
			
				li $t4, 0
				mul $t4, $s6, $t2 # t4 = rowIndex * size
				add $t4, $t4, $s7 # t4 = t4 + colIndex
				mul $t4, $t4, $t3 # t4 = t4 * dataSize
				add $t1, $t1, $t4 # addr = t1 = t1 + t4
			
				lw $t6, ($t1) # carregar valor
				# se valor == 9, incrementar
				bne $t6, $t5, c8
				addi $s5, $s5, 1
			 	
			 	c8:
			 	#l+1, c+1
			 	addi $s6, $t8, 1
			 	addi $s7, $t9, 1
			 	
			 	
			 	la $t1, mdArray
				lw $t2, size
				li $t3, 4 # data_size
				li $t5, 9 # bomba
			
				li $t4, 0
				mul $t4, $s6, $t2 # t4 = rowIndex * size
				add $t4, $t4, $s7 # t4 = t4 + colIndex
				mul $t4, $t4, $t3 # t4 = t4 * dataSize
				add $t1, $t1, $t4 # addr = t1 = t1 + t4
			
				lw $t6, ($t1) # carregar valor
				
				# se valor == 9, incrementar
				bne $t6, $t5, colocarDica
				addi $s5, $s5, 1
				
				colocarDica:
					#switch case para verificar numero
					li $s6, 0
					beq $s6, $s5, zero
					
					li $s6, 1
					beq $s6, $s5, um
					li $s6, 2
					beq $s6, $s5, dois
					li $s6, 3
					beq $s6, $s5, tres
					li $s6, 4
					beq $s6, $s5, quatro
					li $s6, 5
					beq $s6, $s5, cinco
					li $s6, 6
					beq $s6, $s5, seis
					li $s6, 7
					beq $s6, $s5, sete
					li $s6, 8
					beq $s6, $s5, oito	
					
					zero:
						lb $s5, zer
						j escreverDica
					um:
						lb $s5, one
						j escreverDica
					dois:
						lb $s5, two
						j escreverDica
					tres:
						lb $s5, thr
						j escreverDica
					quatro:
						lb $s5, fou
						j escreverDica
					cinco:
						lb $s5, fiv
						j escreverDica
					seis:
						lb $s5, six
						j escreverDica
					sete:
						lb $s5, sev
						j escreverDica
					oito:
						lb $s5, eig
						j escreverDica
					
					escreverDica:
						# achar endereco
						la $t1, print
						lw $t2, size
						li $t3, 1 # data_size
						lb $t5, bombaChar # bomba
				
						li $t4, 0
						mul $t4, $t8, $t2 # t4 = rowIndex * size
						add $t4, $t4, $t9 # t4 = t4 + colIndex
						mul $t4, $t4, $t3 # t4 = t4 * dataSize
						add $t1, $t1, $t4 # addr = t1 = t1 + t4
				
						sb $s5, ($t1) # armazenar @
							
			
			j fimVerificacao
			
			colocarCharBomba:
				# aqui devo pegar a pos equivalente na matriz de chars e colocar @ para representar a bomba
				# row index e col index deve estar sempre armazenados em t8 e t9 respectivamente
				la $t1, print
				lw $t2, size
				li $t3, 1 # data_size
				lb $t5, bombaChar # bomba
				
				li $t4, 0
				mul $t4, $t8, $t2 # t4 = rowIndex * size
				add $t4, $t4, $t9 # t4 = t4 + colIndex
				mul $t4, $t4, $t3 # t4 = t4 * dataSize
				add $t1, $t1, $t4 # addr = t1 = t1 + t4
				
				sb $t5, ($t1) # armazenar @
				
				li $t5, 2
				sw $t5, state #mudar state
				j fimVerificacao
		
		
		
			printMatriz:
		# carregar endereco da matriz em t1 e em k0
		la $t1, mdArray
		la $k0, mdArray
		
		# valor limite
		li $s6, 21
		
		#contador linha
		li $s0, 1
		
		# imprimir linha por linha
		loopLinha:
			# imprimir pular linha(\n)
			li $v0, 4
			la $a0, nline
			syscall
			# se linha = 11, terminar
			beq $s0, $s6, endPrintMatriz
			#contador coluna
			li $s1, 1
			
			loopColuna:
				# carregar valor do endereco em t2
				lw $t2, 0($t1)
				
				# imprimir valor
				li $v0, 1
				move $a0, $t2
				syscall
				
				# optional - syscall number for printing character (space)
    				li      $a0, 32
    				li      $v0, 11  
    				syscall
    
				# avancar para proximo endereco
				mul $t1, $s0, 22
				add $t1, $t1, $s1
				mul $t1, $t1, DATA_SIZE
				add $t1, $t1, $k0
				
				# coluna++
				addi $s1, $s1, 1
			
				# se coluna != 11, continuar loop
				bne $s1, $s6, loopColuna
			
				# senao, linha++
				addi $s0, $s0, 1
				# recomecar
				j loopLinha
		
		endPrintMatriz:
		j contarBombas
		
		
		
		printMatrizChars:
			# carregar endereco da matriz em t1 e em k0
			la $t1, print
		
			# valor limite
			li $s6, 21
		
			#contador linha
			li $s0, 1
		
			# addr = baseAddr + (rowIndex * size + colIndex) * dataSize
			# imprimir linha por linha
			loopLinhaMC:
				# imprimir pular linha(\n)
				li $v0, 4
				la $a0, nline
				syscall
				# se linha = 21, terminar
				beq $s0, $s6, endPrintMatrizChars
				#contador coluna
				li $s1, 1
			
				loopColunaMC:
					# addr = baseAddr + (rowIndex * size + colIndex) * dataSize
					#achar endereço
					li $t8, 0
					li $t9, 22
					mul $t8, $s0, $t9 # rowindex * size
					add $t8, $t8, $s1 # + col index
					li $t9, 1 # datasize
					mul $t8, $t8, $t9 # * datasize
					add $t1, $t1, $t8 # addr = base + resto
					
					#imprimir char
					lb $a0, ($t1)
					li $v0, 11
					syscall
					#imprimir espaço
					li $a0, 32
					li $v0, 11
					syscall
					#incrementar col
					addi $s1, $s1, 1
					
					bne $s1, $s6, loopColunaMC
					# se col == 21 incrementar linha
					addi $s0, $s0, 1
					j loopLinhaMC
			endPrintMatrizChars:
			j solicitarLinCol
			
	printChars2:
		# imprimir pular linha(\n)
				li $v0, 4
				la $a0, nline
				syscall
				
		# carregar endereco da matriz em t1 e em k0
		la $t1, print
		addi $t1,$t1, 22 # pular linha borda e primeira pos da col
		
		# valor limite
		li $s6, 20
		li $s7, 20
		
		#contador
		li $s0, 0
		
		#contador cols
		li $s1, 0
				
		#pular borda
			
		loopPrintChars2:
		
			#imprimir char
			lb $a0, ($t1)
			li $v0, 11
			syscall
			#imprimir espaço
			li $a0, 32
			li $v0, 11
			syscall
			
			#incrementar
			addi $t1, $t1, 1
			addi $s1, $s1, 1
			
			# se col == 20, pular linha
			bne $s1, $s7, justC
			li $s1, 0
			addi $t1, $t1, 2
			addi $s0, $s0, 1
			# imprimir pular linha(\n)
				li $v0, 4
				la $a0, nline
				syscall
			
			justC:
			# se contador != 484, recomeçar
			bne $s0, $s6, loopPrintChars2

			
		j solicitarLinCol
		
	contarAst:
		
		# carregar endereco da matriz em t1 e em k0
		la $t1, print
		addi $t1,$t1, 22 # pular linha borda e primeira pos da col
		
		# valor limite
		li $s6, 20
		li $s7, 20
		
		#contador
		li $s0, 0
		
		#contador cols
		li $s1, 0
				
		#numero de asts
		li $k0, 0
		lb $k1, aster
			
		loopPrintCharss:
		
			#carregar valor e somar
			lb $v0, ($t1)
			bne $k1, $v0, continueContar
			# icrementar numero
			addi $k0, $k0, 1
			
			continueContar:
			#incrementar
			addi $t1, $t1, 1
			addi $s1, $s1, 1
			
			# se col == 20, pular linha
			bne $s1, $s7, justCC
			li $s1, 0
			addi $t1, $t1, 2
			addi $s0, $s0, 1
			
			
			justCC:
			# se contador != 484, recomeçar
			bne $s0, $s6, loopPrintCharss
			#armazenar
			sw $k0, nAsters
			j terminouAst
			
			
	gameover:
		la $a0, perdeu
		li $v0, 4
		syscall
		j fim
		
	gamewin:
		la $a0, ganhou
		li $v0, 4
		syscall
				
	fim:
			
